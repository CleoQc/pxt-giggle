{
  "WhichUniqueMotor": "Voici la librairie pour le GiggleBot de Dexter Industries",
  "gigglebot.DSconfigure": "Configure le senseur de distance.\Doit être appelé avant de prendre la première lecture.",
  "gigglebot.DSreadRangeContinuous": "Obtenir une lecture indiquant à quelle distance se trouve un obstacle.",
  "gigglebot.DStestForObstacle": "Teste la présence d'un obstacle",
  "gigglebot.drive_X_millisec": "Will let gigglebot move forward or backward for a number of milliseconds.\nDistance covered during that time is related to the freshness of the batteries.",
  "gigglebot.drive_straight": "Will let gigglebot move forward or backward until told otherwise (either by a stop block or a turn block).",
  "gigglebot.follow_light": "Will follow a spotlight shone on its eyes. If the spotlight disappears the gigglebot will stop.",
  "gigglebot.follow_line": "A thin black line would fall between the two sensors. The gigglebot will stop when both sensors are reading black.\nA thick black line would have the two sensors on top of it at all times. The gigglebot will stop when both sensors are reading white.",
  "gigglebot.get_light_sensor": "Reads left or right light sensor. \nThe light sensors are placed in front of each eye neopixel, they're tiny! \nThe range is 0 through 1023, although in reality rarely above ~950.",
  "gigglebot.get_line_sensor": "Reads left or right line sensor",
  "gigglebot.get_raw_line_sensors": "Reads the two line sensors",
  "gigglebot.onRemoteControl": "Use this block on the GiggleBot to control it with a second micro:bit",
  "gigglebot.onRemoteControl|param|radio_block": "eg:1",
  "gigglebot.remote_control": "Use this block to turn a second Micro:bit into a remote controller.\nEasiest approach is to put this block inside a \"Forever\" block.\nYou will need to use the \"remote receiver mode\" block on the GiggleBot itself.",
  "gigglebot.remote_control_action": "@param",
  "gigglebot.remote_control|param|radio_block": "eg: 1",
  "gigglebot.set_speed": "You can set the speed for each individual motor or both together. The higher the speed the less control the robot has.\nYou may need to correct the robot (see block in \"more...\" section).  A faster robot needs more correction than a slower one.\nIf you want to follow a line,  it will work best at a lower speed.\nActual speed is dependent on the freshness of the batteries.",
  "gigglebot.share_smile": "Lets you use the blocks in the neopixel category for better control over the smile/rainbow.",
  "gigglebot.show_line_graph": "Use the smile lights to display a line graph of a certain value on a graph of 0 to Max value",
  "gigglebot.show_voltage": "Displays the current battery voltage. Anything lower than 3.4 is too low to run the motors",
  "gigglebot.smile_cycle_rainbow": "Displays the colors of the rainbow on the lights and cycles through them",
  "gigglebot.smile_cycle_rainbow_time": "Displays the colors of the rainbow on the lights and cycles through them based on times",
  "gigglebot.smile_cycle_rainbow_time|param|cycle_length": "how long (in ms) the cycling will last for: eg: 3000",
  "gigglebot.smile_cycle_rainbow_time|param|delay": "how long to wait(in ms) before cycling; eg: 100, 200",
  "gigglebot.smile_cycle_rainbow|param|nbcycles": "how many times the rainbow will do a full cycle; eg: 3, 5, 10",
  "gigglebot.smile_rainbow": "Will display a rainbow of colors on the smile lights.",
  "gigglebot.stop": "Ce bloc arrête le Gigglebot.",
  "gigglebot.test_line": "Will return true if the whole line sensor is reading either black or white.",
  "gigglebot.turn": "Will make gigglebot turn left or right until told otherwise (by a stop block or a drive block).",
  "gigglebot.turn_X_millisec": "Will make gigglebot turn left and right for a number of milliseconds. How far it turns depends on the freshness of the batteries.",
  "gigglebot.which_eye": "Lets you use the blocks in the neopixel category for better control over the eyes."
}